# -*- coding: utf-8 -*-
"""Minimax - Tictactoe.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XtaCDwVp1ca559IcE_4RHhdXV9_82ts7

#TicTacToe Game vs Computer

#Background

This app will allow you to play tic tac toe with the computer implementing the minimax adversarial search algorithm with some possible Alpha beta prunning. Remember that the worst score is -10, the tie is 0 and the best score for the agent is +10

What I have realized:
* the board is full or not
if the board is full then we are at a terminal state and if so then we have to decide if we have a tie, win or loss by the agent
* we are either maximizing or minimizing the score 
* we must find a way to draw the board
* then execute the move according to the algorithm
* call minimax on all 8 or less possible moves after the agent goes first
* player is X and computer is 0

#Setup with Functions
"""

#first we need to make the board and present it 
#We will write up a list of functions

import copy,math
from operator import itemgetter

#----------------------------------
#------- Me: 0 -------------  Computer: 1------
board = [['-','-','-'], ['-','-','-'], ['-','-','-']]
draw = {0: 'O', 1:'X'}
letters = {'a':(0,0) , 'b':(0,1), 'c':(0,2), 'd':(1,0), 'e':(1,1), 'f':(1,2), 'g':(2,0), 'h':(2,1), 'i':(2,2)}
filled = [i for i in letters.keys()]

def print_board(board):
  for i in range(3):
    for j in range(3):
      print(board[i][j], end=' | ')
    print()
  print("-------------------------")

def print_letter_board(board):
  count = 0
  for i in letters.keys():
    x,y = letters[i][0], letters[i][1]
    if board[x][y] == '-':
      print(i,end = ' | ') 
    else: 
      print('-',end = ' | ') 
    count+=1
    if count == 3 or count == 6:
      print("\n-------")

def clear_board(board):
  for i in range(3):
    for j in range(3):
      board[i][j] = '-'

def d_chk(board,player):
  first, sec = False,False
  if board[0][0] == board[1][1] == board[2][2] == draw[player]:
    first = True
  if board[2][0] == board[1][1] == board[0][2] == draw[player]:
    sec = True
  return first or sec

def hor_chk(board,player):
  first,sec,third = False,False,False
  if board[0][1] == board[0][2] == board[0][0] == draw[player]:
    first = True
  if board[1][1] == board[1][2] == board[1][0] == draw[player]:
    sec = True
  if board[2][1] == board[2][2] == board[2][0] == draw[player]:
    third = True
  return first or sec or third

def ver_chk(board,player):
  first,sec,third = False,False,False
  if board[0][0] == board[1][0] == board[2][0] == draw[player]:
    first = True
  if board[0][1] == board[1][1] == board[2][1] == draw[player]:
    sec = True
  if board[0][2] == board[1][2] == board[2][2] == draw[player]:
    third = True
  return first or sec or third

def isFull(board):
  count = 0
  for i in range(3):
    for j in range(3):
      if board[i][j] != '-':
        count+=1
  return count == 9

def makeMove(board,ltr,player):
  #we return the move made or letter
  x,y = letters[ltr][0], letters[ltr][1]
  if board[x][y] == '-':
    board[x][y] = draw[player]
    #print(f'The move made by player {player+1} was at letter: {ltr}')
    return ltr

def isValid(board,ltr):
  x,y = letters[ltr][0], letters[ltr][1]
  if board[x][y] == '-':
    return True
  else:
    return False
  
def score(board,player):
  '''
    return either 10, 0, -10
    player = 0 is me 10 ->> O
    player = 1 is computer -10 ->> X
  '''
  if player == 0:
    if d_chk(board,player) or ver_chk(board,player) or hor_chk(board,player):
      return  10

  if player == 1:
    if d_chk(board,player) or ver_chk(board,player) or hor_chk(board,player):
      return  -10
  return 0

def moves_left(board):
  #Now we need to find empty spaces
  filling = []
  for ltr in filled:
    x,y = letters[ltr][0], letters[ltr][1]
    if board[x][y] == '-':
      filling.append(ltr)
  return filling


def winner(board,player):
  if d_chk(board,player) or hor_chk(board,player) or ver_chk(board,player):
      #print("Hooray, player " + str(player+1) + " has won!!")
      return True
  return False


def minimax(depth,min_max,player,board,last_move,nums):
  if winner(board,player):
    #print("Going backwards ciz winner")
    if player == 0:
     # print("minimax returns 10, so you win")
      return 10 - nums
    elif player == 1:
      #print("minimax returns - 10 so computer wins")
      return -10 + nums
  elif depth == 0:
    #print("depth is 0")
    return 0 + nums
  elif isFull(board):
    #print("Going backwards ciz full")
    return 0 + nums 
  scores = []
  #print(scores)
  moves = moves_left(board)
  #print(f'Moves left for the after the last move: {last_move} is {moves}')
  for move in moves:
    new_board = copy.deepcopy(board)
    op_player = player
    if op_player == 0:
      op_player = 1
    else:
      op_player = 0
    makeMove(new_board,move,op_player) #tells which move was made
    #print(f'The Move made before the minimax call was {move}')
    n = nums + 1
    #print(f'The move is {move} and the number of moves made is {n} ')
    m = minimax(depth-1,min_max * -1, op_player,new_board,move,n)
    #print("About to append " + str(m) + 'for the move ' + move)
    scores.append(m)
    #print(f'The move was {move}')
    #print(scores)
    #print(max(scores))
    #print("-------")
    if min_max == 1:
      maxy = max(scores)
      #print("about to return maxy which is " + str(maxy))
      return maxy
    elif min_max == -1:
      #print(scores)
      miny = min(scores)
      #print("about to return miny which is " + str(miny))
      return miny

def best_move(board,last_move):
  scores = []
  moves = moves_left(board)
  for move in moves:
    new_board = copy.deepcopy(board)
    makeMove(new_board,move,1)
    m = minimax(10000,1,1,new_board,move,0)
    #print(f'We are in best_move, made the move {move} and the minimax score is {m}')
    scores.append((move,m))
  #print(f'The scores list for the move {last_move} is {scores}')
  if scores == []:
    return "end"
  maxy = min(scores, key = itemgetter(1))
  #print(f'BEST MOVE IS AT {maxy[0]}')
  return maxy[0]

"""#Driver Code"""

def main():
  print("Welcome to this TicTacToe game, impossible to beat")
  print("Here is the board right now, pick a letter between a and i to start")
  print("You are the agent and you are the O's so good luck")
  print_board(board)
  not_ending = True
  p1 = 0
  while True:
    print_board(board)
    if p1 == 0:
      print_board(board)
      print_letter_board(board)
      letter = input("Mark a letter between a and i!")
      if letter not in moves_left(board):
        continue
      makeMove(board,letter,0)
      print_board(board)
      if winner(board,p1):
        print("You win!")
        break
      print("Now it is the computer's turn")
      p1 = 1
    else:
      letter = best_move(board,letter)
      if letter == "end":
        print("we have a tie")
        break
      makeMove(board,letter,1)
      print_board(board)
      #print_letter_board(board)
      if winner(board,p1):
        print("You lost!")
        break
      print("Now it's your turn")
      p1 = 0

if __name__ == "__main__":
  clear_board(board)
  main()

